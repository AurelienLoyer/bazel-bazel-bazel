:revealjsdir: https://cdn.rawgit.com/hakimel/reveal.js/3.8.0/
:revnumber: {project-version}
:example-caption!:
ifndef::imagesdir[:imagesdir: images]
:docinfo: shared
:navigation:
:menu:
:header_footer: true
:status:
:slideNumber: true
:showSlideNumber: true
:title-slide-transition: zoom
:title-slide-transition-speed: fast
:icons: font
:revealjs_history: true

[.black.background]
== !

[.notes]
--
Aurelien

* Epoque ou la taille de nos projet est de plus en grande
* Le nombre de dependances grossit de jour en jour
* Duree d'un build et de nots tests sont trop long pour avoir un feedback rapidement. 
* Inner source 
* Probl√®me connu
* En effet, des grosses soci√©tes se sont pench√©s sur le sujet, et notamment Google qui propose ...  
* Bonne id√©e de parler de Qima

--

== !

image::bazel.png[]

[.notes]
--
Aurelien
l'outil open-source Bazel que nous allons vous pr√©senter aujourd'hui
--

include::chapters/00-speakers.adoc[]

include::chapters/01-chezgoogle.adoc[]

include::chapters/02-function-pure.adoc[]

include::chapters/03-angular.adoc[]

== !

NOTE: Il faut voir Bazel comme un orchestrateur, et non comme un nouvel outil de build √† apprendre

[.notes]
--
--

== üá´üá∑ Multi Langage

[.column]
* Android
* C / C++
* C#
* Docker
* Go
* Groovy

[.column]
* Kotlin
* iOS
* Java
* Javascript
* Perl
* Python

[.column]
* Ruby
* Rust
* Sass
* Shell
* Typescript
* ...

[.notes]
--
Parler d'extensibilite. 
faut indiquer que certains des languages sont support√©s par d√©faut. 
--

== Getting Started

++++
<iframe src="https://giphy.com/embed/1BFGiiHYS2dAbC0Lx1" width="480" height="480" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
++++

[.notes]
--
TODO: 
- Parler de la granularit√© a utiliser. comme mave ? ou une granulatie plus petite. on gagne en performance, mais on perd en maintenabilite
--

include::chapters/starlark.adoc[]

== Workspace / Package

[.hidden-title]
=== !

image::monoreposgoogle.png[structure,600,600]

=== !

[source,python]
----
// WORKSPACE
http_archive(
    name = "build_bazel_rules_nodejs",
    sha256 = "1249a60f88e4c0a46d78de06be04d3d41e7421dcfa0c956de65309a7b7ecf6f4",
    urls = ["https://github.com/bazelbuild/rules_nodejs/releases/download/0.38.0/rules_nodejs-0.38.0.tar.gz"],
)
----

== Rule / Target

=== Utiliser une rule

[source,python]
----
// BUILD.bazel
genrule(
    srcs = [ ... ],
    outs = [ ... ],
    cmd = " ... ",
)
----

[.notes]
--
TODO: 
- appeler gen_rule
--

=== Cr√©er une target

[source,python]
----
// BUILD.bazel
genrule(
    name = "copy-file",
    srcs = [ ... ],
    outs = [ ... ],
    cmd = " ... ",
)
----

[.notes]
--
TODO: 
- appeler gen_rule
--

== Les labels

Un label correspond √† 

* un fichier 
* une target

=== Les labels

* //gcp/finance:front	
* //gcp/finance
* //gcp/finance:all
* //gcp/...

[.notes]
--
--

=== Les labels

Si je suis dans le r√©pertoire `gcp`

* :all == //gcp:all
* finance:front == //gcp/finance:front

[.notes]
--
--

== Cr√©er une target

[source,python]
---- 
// //gcp/BUILD.bazel
genrule(
    name = "copy-file",
    srcs = [
        "//angular:README.md",
    ],
    outs = ["README-gcp.md"],
    cmd = "cp $< $@",
)
----

== D√©pendances

[source,python]
----
// //gcp/BUILD.bazel
genrule(
    name = "copy-file",
    srcs = [
        "//angular:README.md",
    ],
    outs = ["README-gcp.md"],
    cmd = "cp $< $@",
)

genrule(
    name = "concat",
    srcs = [
        "copy-file", "//:LICENCE",
    ],
    outs = ["final.txt"],
    cmd = "cat $(locations //copy-file) $(location //some:file2) > $@",
)
----

[.notes]
--
TODO: 
- appeler gen_rule apres une autre genrule pour montrer la dependances
--

== Macro

[source,python]
----
// //:rules.bzl
def generate_final_txt(name, **kwargs):
    genrule(
        name = "%s_first" % name,
        srcs = [
            "//angular:README.md",
        ],
        outs = ["README-gcp.md"],
        cmd = "cp $< $@",
    )

    genrule(
        name = name,
        **kwargs
    )
----

=== Macro

[source,python]
----
load("//:rules.bzl", "generate_final_txt")

generate_final_txt(
    name = "concat",
    srcs = [
        "copy-file", "//:LICENCE",
    ],
    outs = ["final.txt"],
    cmd = "cat $(locations //copy-file) $(location //some:file2) > $@"
)
----

== Custom rules

[source,python]
----
def ts_binary_impl(ctx):
  files = list(get_transitive_files(ctx))
  output = ctx.outputs.out
  flags = ' '.join(ctx.attr.flags)
  ctx.action(
      inputs=files,
      outputs=[output],
      command="tsc %s --out %s %s" % (
          flags, output.path, ' '.join([f.path for f in files])))

ts_binary = rule(
  implementation = ts_binary_impl,
  attrs = {
      "srcs": attr.label_list(allow_files=ts_filetype),
      "deps": attr.label_list(allow_files=False),
      "flags": attr.string_list(),
  },
  outputs = {"out": "%{name}.js"},
)]
----

include::chapters/demo.adoc[]

include::chapters/conclusion.adoc[]

include::chapters/thanks.adoc[]
